{"remainingRequest":"D:\\front-end files\\test\\my-gridsome\\node_modules\\babel-loader\\lib\\index.js??ref--1-1!D:\\front-end files\\test\\my-gridsome\\node_modules\\gridsome\\app\\fetchPath.js","dependencies":[{"path":"D:\\front-end files\\test\\my-gridsome\\node_modules\\gridsome\\app\\fetchPath.js","mtime":1628149246770},{"path":"D:\\front-end files\\test\\my-gridsome\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1628149244789},{"path":"D:\\front-end files\\test\\my-gridsome\\node_modules\\babel-loader\\lib\\index.js","mtime":1628149244548}],"contextDependencies":[],"result":["import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport fetch from './fetch';\nimport router from './router';\nimport { getResults, setResults, formatError } from './graphql/shared';\nexport default function fetchPath(path) {\n  if (process.isServer) {\n    throw new Error(\"Cannot fetch \".concat(path, \" while rendering HTML. \") + \"This method should ony be used in the mounted hook.\");\n  }\n\n  var _router$resolve = router.resolve({\n    path: path\n  }),\n      route = _router$resolve.route;\n\n  var cached = getResults(route.path);\n  var notFoundErr = new Error(\"Could not find \".concat(path));\n  return new Promise(function (resolve, reject) {\n    if (route.fullPath !== path) return reject(notFoundErr);\n    if (route.name === '*') return reject(notFoundErr);\n    if (cached) return resolve(cached);\n    fetch(route).then(function (res) {\n      if (res.code === 404) reject(notFoundErr);else resolve(setResults(route.path, res));\n    })[\"catch\"](function (err) {\n      if (err.code === 'MODULE_NOT_FOUND' || err.code === 404) {\n        reject(notFoundErr);\n      } else {\n        formatError(err, route);\n        reject(err);\n      }\n    });\n  });\n}",{"version":3,"sources":["D:/front-end files/test/my-gridsome/node_modules/gridsome/app/fetchPath.js"],"names":["fetch","router","getResults","setResults","formatError","fetchPath","path","process","isServer","Error","resolve","route","cached","notFoundErr","Promise","reject","fullPath","name","then","res","code","err"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,SAAlB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AAEA,SACEC,UADF,EAEEC,UAFF,EAGEC,WAHF,QAIO,kBAJP;AAMA,eAAe,SAASC,SAAT,CAAoBC,IAApB,EAA0B;AACvC,MAAIC,OAAO,CAACC,QAAZ,EAAsB;AACpB,UAAM,IAAIC,KAAJ,CACJ,uBAAgBH,IAAhB,oFADI,CAAN;AAID;;AAED,wBAAkBL,MAAM,CAACS,OAAP,CAAe;AAAEJ,IAAAA,IAAI,EAAJA;AAAF,GAAf,CAAlB;AAAA,MAAQK,KAAR,mBAAQA,KAAR;;AACA,MAAMC,MAAM,GAAGV,UAAU,CAACS,KAAK,CAACL,IAAP,CAAzB;AACA,MAAMO,WAAW,GAAG,IAAIJ,KAAJ,0BAA4BH,IAA5B,EAApB;AAEA,SAAO,IAAIQ,OAAJ,CAAY,UAACJ,OAAD,EAAUK,MAAV,EAAqB;AACtC,QAAIJ,KAAK,CAACK,QAAN,KAAmBV,IAAvB,EAA6B,OAAOS,MAAM,CAACF,WAAD,CAAb;AAC7B,QAAIF,KAAK,CAACM,IAAN,KAAe,GAAnB,EAAwB,OAAOF,MAAM,CAACF,WAAD,CAAb;AACxB,QAAID,MAAJ,EAAY,OAAOF,OAAO,CAACE,MAAD,CAAd;AAEZZ,IAAAA,KAAK,CAACW,KAAD,CAAL,CACGO,IADH,CACQ,UAAAC,GAAG,EAAI;AACX,UAAIA,GAAG,CAACC,IAAJ,KAAa,GAAjB,EAAsBL,MAAM,CAACF,WAAD,CAAN,CAAtB,KACKH,OAAO,CAACP,UAAU,CAACQ,KAAK,CAACL,IAAP,EAAaa,GAAb,CAAX,CAAP;AACN,KAJH,WAKS,UAAAE,GAAG,EAAI;AACZ,UAAIA,GAAG,CAACD,IAAJ,KAAa,kBAAb,IAAmCC,GAAG,CAACD,IAAJ,KAAa,GAApD,EAAyD;AACvDL,QAAAA,MAAM,CAACF,WAAD,CAAN;AACD,OAFD,MAEO;AACLT,QAAAA,WAAW,CAACiB,GAAD,EAAMV,KAAN,CAAX;AACAI,QAAAA,MAAM,CAACM,GAAD,CAAN;AACD;AACF,KAZH;AAaD,GAlBM,CAAP;AAmBD","sourcesContent":["import fetch from './fetch'\r\nimport router from './router'\r\n\r\nimport {\r\n  getResults,\r\n  setResults,\r\n  formatError\r\n} from './graphql/shared'\r\n\r\nexport default function fetchPath (path) {\r\n  if (process.isServer) {\r\n    throw new Error(\r\n      `Cannot fetch ${path} while rendering HTML. ` +\r\n      `This method should ony be used in the mounted hook.`\r\n    )\r\n  }\r\n\r\n  const { route } = router.resolve({ path })\r\n  const cached = getResults(route.path)\r\n  const notFoundErr = new Error(`Could not find ${path}`)\r\n\r\n  return new Promise((resolve, reject) => {\r\n    if (route.fullPath !== path) return reject(notFoundErr)\r\n    if (route.name === '*') return reject(notFoundErr)\r\n    if (cached) return resolve(cached)\r\n\r\n    fetch(route)\r\n      .then(res => {\r\n        if (res.code === 404) reject(notFoundErr)\r\n        else resolve(setResults(route.path, res))\r\n      })\r\n      .catch(err => {\r\n        if (err.code === 'MODULE_NOT_FOUND' || err.code === 404) {\r\n          reject(notFoundErr)\r\n        } else {\r\n          formatError(err, route)\r\n          reject(err)\r\n        }\r\n      })\r\n  })\r\n}\r\n"]}]}